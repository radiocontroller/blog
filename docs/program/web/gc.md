# 垃圾回收算法
---

### 引用计数算法
* 引用计数算法很简单，它实际上是通过在对象头中分配一个空间来保存该对象被引用的次数。如果该对象被其它对象引用，则它的引用计数加一，
如果删除对该对象的引用，那么它的引用计数就减一，当该对象的引用计数为0时，那么该对象就会被回收。

* 我们一般也称呼引用计数垃圾收集为直接的垃圾收集机制，而下面三种标记算法都属于间接的垃圾收集机制（内存空间不够触发，此时会stop-the-world）。

### 标记清除算法
* 标记：通过根节点(GC Roots)，把所有从GC Roots开始的对象进行标记，而未被标记的对象就会被视为已经无用，也就是可以回收的对象。
* 清除：清除掉所有未被标记的对象。
* 适用场景：适用于对象存活率高的场景。
* 缺陷：会产生大量的内存碎片。每次清除原有对象的同时，就会把原有对象占用的内存空间给腾出来，就可能会导致内存的不连续，从而产生大量的内存碎片
当程序中有一个较大的对象想要放入内存时，需要占用一大段连续内存，这时候的内存中因为都是碎片，没有连续的内存，就会导致程序再去调用算法进行垃圾回收。

### 标记复制算法
* 该算法依然会去标记目前存活的对象，但与标记清除算法不同。
在标记之后，复制算法会将目前存活的对象复制+移动到另一块内存中，然后将原来的内存块全部清除掉。
这里的复制+移动，是要将原内存块中的对象顺序排列成连续性的，以留存出更大具有连续性的内存。
所以我们可以得出一个结论，就是复制算法必须要有两块内存才可以实施。
* 适用场景：适用于对象存活率低的场景，只有存活率够低，复制的时候所消耗的性能则会越低。
* 缺陷：缺点就是必须要有两块内存，这样就会导致本来可以任其获取的内存目前缩水了一半，这也是复制算法不能全部应用在虚拟机内存的原因。移动的时候也会消耗一定的性能。此算法不会留下内存碎片。

### 标记整理算法
* 该算法继续沿用了标记功能，在标记之后，先将存活对象都全部移动到内存的一端，然后根据最后一个存活对象的位置，将在其之后的所有空间清理掉。
* 适用场景：中规中矩，均可。
* 缺陷：并没有非常明显的缺点，主要还是因为解决碎片化和内存消耗过大的问题衍生出来的。
* 相对于标记清除算法，该算法不会产生大量碎片，是标记清除算法的改良版。
* 相对于复制算法，该算法不会无端占用过多的内存。

::: tip 参考链接

[https://juejin.cn/post/6977272406821830670](https://juejin.cn/post/6977272406821830670)

[https://www.jianshu.com/p/1d5fa7f6035c](https://www.jianshu.com/p/1d5fa7f6035c)

[https://xie.infoq.cn/article/9d4830f6c0c1e2df0753f9858](https://xie.infoq.cn/article/9d4830f6c0c1e2df0753f9858)

:::
