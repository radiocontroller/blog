# 面试题总结
---

### 1、Redis持久化机制
* Redis 是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来 保证数据持久化。
当 Redis 重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。实现：单独fork一个子进程，
将当前父进程的数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，
再用这个临时文件替换上次的快照文件，然后子进程退出。

* RDB：Redis默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。
即 Snapshot 快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的 save 参数来定义快照的周期。

* AOF：Redis会将每一个收到的写命令都通过 Write 函数追加到文件最后，类似于 MySQL 的 binlog。

* 当 Redis 重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。当两种方式同时开启时，Redis 会优先选择 AOF 恢复数据。
---

### 2、Redis过期key处理策略
1. 定期删除：redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。
为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！

2. 惰性删除。定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，
还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！

* redis使用的过期键值删除策略是：定期删除 + 惰性删除。
---

### 3、缓存穿透
::: tip 解释
一般的缓存系统都是按key去缓存查询，如果不存在对应的value，就去查数据库。
一些恶意的请求会故意大量查询不存在的key，就会对数据库造成很大的压力，这就叫做缓存穿透。
简单的说就是故意避开缓存去数据库查询数据。场景：当客户端发起查询时，缓存中没有就会去查库，库里也没有，就会返回给客户端错误信息。
这样是没问题的，看起来逻辑是完美的。但是这里存在一个漏洞，那就是无论什么样的Key过来查，都接受它的请求，这就可能会被黑客抓住，发起大量请求，
并且key都是系统中没有的，库里也查不到对应的值，这样的Key称之为非法key。那么当大量这样的请求过来时都不会命中Redis，然后都会打到DB上，
当DB瞬时接收到如此多的连接时，DB就有可能撑不住，挂掉。这就是存在的一个隐藏的漏洞，黑客或者恶意攻击者就会抓住这一点攻击你的系统，使你的系统瘫痪。
:::

* 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

* 另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），
我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。
---

### 4、缓存击穿
::: tip 解释
针对缓存中没有但数据库有的数据。场景是，当Key失效后，假如瞬间突然涌入大量的请求，来请求同一个Key，这些请求不会命中Redis，都会请求到DB，
导致数据库压力过大，甚至扛不住，挂掉。
:::

* 设置热点Key，自动检测热点Key，将热点Key的过期时间加大或者设置为永不过期，或者设置为逻辑上永不过期，具体设置方法待会说。

* 加互斥锁。当发现没有命中Redis，去查数据库的时候，在执行更新缓存的操作上加锁，谁拿到锁谁去更新，同时在拿到锁之后先从缓存再获取一次如果有就返回，没有就查库然后更新。（双重校验）
---

### 5、缓存雪崩
::: tip 解释
缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是, 缓存击穿指并发查同一条数据，
缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。简单地说就是缓存大量过期去数据库查询数据。
:::
* 设置key过期时间时，加上一个随机数
---

### 6、如何保证缓存与数据库双写时的数据一致性
::: tip Cache Aside Pattern
* 读的时候先读缓存，有缓存直接返回；如果缓存不存在的话就读数据库，取出数据后更新缓存。
* 写的时候，先更新数据库，再<b>删除</b>缓存。
:::

* 如果不是严格要求“缓存和数据库”必须保证一致性的话，最好不要做这个方案：即 读请求和写请求串行化，串到一个内存队列里面去。
串行化可以保证一定不会出现不一致的情况，但会导致系统吞吐量大幅度降低。

#### 为什么是删除缓存，而不是更新缓存？
* 很多时候复杂的缓存场景，缓存可能是关联多张表的数据并通过计算得到缓存的值，即更新缓存的代价比较高。
对于需要频繁写操作，而读操作很少的时候，每次进行数据库的修改，缓存也要随之更新，会造成系统吞吐的下降。
* 两个并发写请求过来，可能会导致数据不一致，例如：A写库，B写库，B更新缓存，A更新缓存

#### Cache Aside Pattern存在的问题
* 问题：先更新数据库，再删除缓存，如果删除缓存失败了，导致数据库中是新数据，缓存中是旧数据，就出现数据不一致的问题。

* 并发问题：比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，
此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。
这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。
而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，
所有的这些条件都具备的概率基本并不大。