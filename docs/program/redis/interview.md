# 关键问题总结
---

### 1、Redis为什么快
* 单线程
* 基于内存操作
* 利用io多路复用机制 [https://zhuanlan.zhihu.com/p/296484467](https://zhuanlan.zhihu.com/p/296484467)

### 2、Redis持久化机制
* RDB做镜像全量持久化，AOF做增量持久化。
> RDB持久化也分两种：SAVE和BGSAVE。

> SAVE是阻塞式的RDB持久化，当执行这个命令时redis的主进程把内存里的数据库状态写入到RDB文件中，
直到该文件创建完毕的这段时间内redis将不能处理任何命令请求；

> BGSAVE属于非阻塞式的持久化，它会创建一个子进程专门去把内存中的数据库状态写入RDB文件里，同时主进程还可以处理来自客户端的命令请求。
但子进程基本是复制的父进程，这等于两个相同大小的redis进程在系统上运行，会造成内存使用率的大幅增加。

* AOF的持久化是通过命令追加、文件写入和文件同步三个步骤实现的。
> 当redis开启AOF后（redis备份方式默认是RDB）;
服务端每执行一次写操作（如set、sadd、rpush）就会把该条命令追加到一个单独的AOF缓冲区的末尾，这就是命令追加；然后把AOF缓冲区的内容写入AOF文件里。

> 看上去第二步就已经完成AOF持久化了那第三步是干什么的呢？这就需要从系统的文件写入机制说起：一般我们现在所使用的操作系统，为了提高文件的写入效率，
都会有一个写入策略，即当你往硬盘写入数据时，操作系统不是实时的将数据写入硬盘，而是先把数据暂时的保存在一个内存缓冲区里，
等到这个内存缓冲区的空间被填满或者是超过了设定的时限后才会真正的把缓冲区内的数据写入硬盘中。也就是说当redis进行到第二步文件写入的时候，
从用户的角度看是已经把AOF缓冲区里的数据写入到AOF文件了，但对系统而言只不过是把AOF缓冲区的内容放到了另一个内存缓冲区里而已，
之后redis还需要进行文件同步把该内存缓冲区里的数据真正写入硬盘上才算是完成了一次持久化。

> 而何时进行文件同步则是根据配置的appendfsync来进行：appendfsync有三个选项：always、everysec和no：

* Redis AOF文件过大？AOF重写的作用？
> 随着命令不断的写入数据，AOF文件会越来越大。为了解决这个问题，redis引入了AOF文件重写机制，以便压缩AOF体积，
更小的AOF文件可以更快的被redis加载。从Redis2.4开始，AOF重写由Redis自行触发，可以使用BGREWRITEAOF手动触发重写操作

> AOF重写的作用：减少磁盘占用量、加速恢复速度（AOF重写会整合一下，比如三条set改为一条）
---

### 3、Redis过期key处理策略
1. 定期删除：redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。
为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！

2. 惰性删除。定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，
还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！

* redis使用的过期键值删除策略是：定期删除 + 惰性删除。
---

### 4、缓存穿透
::: tip 解释
一般的缓存系统都是按key去缓存查询，如果不存在对应的value，就去查数据库。
一些恶意的请求会故意大量查询不存在的key，就会对数据库造成很大的压力，这就叫做缓存穿透。
简单的说就是故意避开缓存去数据库查询数据。场景：当客户端发起查询时，缓存中没有就会去查库，库里也没有，就会返回给客户端错误信息。
这样是没问题的，看起来逻辑是完美的。但是这里存在一个漏洞，那就是无论什么样的Key过来查，都接受它的请求，这就可能会被黑客抓住，发起大量请求，
并且key都是系统中没有的，库里也查不到对应的值，这样的Key称之为非法key。那么当大量这样的请求过来时都不会命中Redis，然后都会打到DB上，
当DB瞬时接收到如此多的连接时，DB就有可能撑不住，挂掉。这就是存在的一个隐藏的漏洞，黑客或者恶意攻击者就会抓住这一点攻击你的系统，使你的系统瘫痪。
:::

* 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

* 另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），
我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。
---

### 5、缓存击穿
::: tip 解释
针对缓存中没有但数据库有的数据。场景是，当Key失效后，假如瞬间突然涌入大量的请求，来请求同一个Key，这些请求不会命中Redis，都会请求到DB，
导致数据库压力过大，甚至扛不住，挂掉。
:::

* 设置热点Key，自动检测热点Key，将热点Key的过期时间加大或者设置为永不过期，或者设置为逻辑上永不过期，具体设置方法待会说。

* 加互斥锁。当发现没有命中Redis，去查数据库的时候，在执行更新缓存的操作上加锁，谁拿到锁谁去更新，同时在拿到锁之后先从缓存再获取一次如果有就返回，没有就查库然后更新。（双重校验）
---

### 6、缓存雪崩
::: tip 解释
缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是, 缓存击穿指并发查同一条数据，
缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。简单地说就是缓存大量过期去数据库查询数据。
:::
* 设置key过期时间时，加上一个随机数
---

### 7、如何保证缓存与数据库双写时的数据一致性
::: tip Cache Aside Pattern
* 读的时候先读缓存，有缓存直接返回；如果缓存不存在的话就读数据库，取出数据后更新缓存。
* 写的时候，先更新数据库，再<b>删除</b>缓存。
:::

* 如果不是严格要求“缓存和数据库”必须保证一致性的话，最好不要做这个方案：即 读请求和写请求串行化，串到一个内存队列里面去。
串行化可以保证一定不会出现不一致的情况，但会导致系统吞吐量大幅度降低。

#### 为什么是删除缓存，而不是更新缓存？
* 很多时候复杂的缓存场景，缓存可能是关联多张表的数据并通过计算得到缓存的值，即更新缓存的代价比较高。
对于需要频繁写操作，而读操作很少的时候，每次进行数据库的修改，缓存也要随之更新，会造成系统吞吐的下降。
* 两个并发写请求过来，可能会导致数据不一致，例如：A写库，B写库，B更新缓存，A更新缓存

#### Cache Aside Pattern存在的问题
* 问题：先更新数据库，再删除缓存，如果删除缓存失败了，导致数据库中是新数据，缓存中是旧数据，就出现数据不一致的问题。

* 并发问题：比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，
此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。
这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。
而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，
所有的这些条件都具备的概率基本并不大。

### 8、查找key
* 1. 使用keys指令可以扫出指定模式的key列表：keys pre*
> redis是单线程的。keys指令会导致线程阻塞一段时间，直到指令执行完毕，才能相应其他客户端请求
* 2. 使用scan
> scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。

