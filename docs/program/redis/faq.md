# FAQ
---

### 1、Redis为什么快
* 单线程
* 基于内存操作
* 利用io多路复用机制 [https://zhuanlan.zhihu.com/p/296484467](https://zhuanlan.zhihu.com/p/296484467)

### 2、Redis支持哪几种数据类型？
* 字符串String
* 字典Hash
* 列表List
* 集合Set
* 有序集合SortedSet
* **如果你是Redis中高级用户，还需要加上下面几种数据结构[Bitmap](https://www.cnblogs.com/wuhaidong/articles/10389484.html)、
    [HyperLogLog](https://segmentfault.com/a/1190000020523110)、Geo、Pub/Sub。**

### 3、Redis持久化机制（默认机制是RDB）
* RDB做镜像全量持久化，AOF做增量持久化。
  * RDB持久化也分两种：save和bgsave。
  * save是阻塞式的，执行时redis的主进程把内存里的数据写入到RDB文件中，直到该文件创建完毕的这段时间内redis将不能处理任何命令请求；
  * bgsave属于非阻塞式，它会创建一个子进程专门去把内存中的数据写入RDB文件里，同时主进程还可以处理客户端的请求。
    但子进程基本是复制的父进程，这等于两个相同大小的redis进程在系统上运行，会造成内存使用率的大幅增加。

* AOF的持久化是通过命令追加、文件写入和文件同步三个步骤实现的。
  * 当redis开启AOF后，服务端每执行一次写操作（如set、sadd、rpush）就会把该条命令追加到一个单独的AOF缓冲区的末尾，然后把AOF缓冲区的内容写入AOF文件里。
  * 而何时进行文件同步则是根据配置的appendfsync来进行，appendfsync有三个选项：always、everysec（默认值）和no
  
* Redis AOF文件过大？AOF重写的作用？
  * 随着命令不断的写入数据，AOF文件会越来越大。为了解决这个问题，redis引入了AOF文件重写机制，以便压缩AOF体积。
  * AOF重写的作用：减少磁盘占用量、加速恢复速度（AOF重写会整合一下，比如三条set改为一条）

* Redis 在 4.0 版本之后，引入了混合持久化方式，而且在 5.0 版本后默认开启。
  * RDB 加载速度快，但缺少最新数据。AOF 持续追加写记录，可以包含所有数据，但加载速度慢。混合模式一体化使用 RDB + AOF，包含全量数据，加载速度也比较快。
  > 可以使用 aof-use-rdb-preamble 配置来明确打开混合持久化模式。

  * 混合持久化也是通过 bgrewriteaof 来实现的。当启用混合存储后，进行 bgrewriteaof 时，主进程首先依然是 fork 一个子进程，
    子进程首先将内存数据以 RDB 的二进制格式写入 AOF 临时文件中。然后，再将落地期间缓冲的新增写指令，以命令的方式追加到该临时文件。
    然后再通知主进程落地完毕。主进程将临时文件修改为 AOF 文件，并关闭旧的 AOF 文件。这样主体数据以 RDB 格式存储，
    新增指令以命令方式追加的混合存储方式进行持久化（在同一个文件）。后续执行的任务，以正常的命令方式追加到新的 AOF 文件即可。

  * 混合持久化综合了 RDB 和 AOF 的优缺点，优势是包含全量数据，加载速度快。不足是头部的 RDB 格式兼容性和可读性较差。
---

### 4、redis重启时数据如何恢复
* 当appendonly配置项为no时redis启动后会去加载RDB文件来恢复数据

* 而appendonly配置项为yes时redis启动后会加载AOF文件来恢复数据
> 如果同时配置了aof-use-rdb-preamble yes，那么以混合方式恢复
---

### 5、Redis过期key处理策略
1. 定期删除：redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。
为什么要随机呢？你想一想假如 redis 存了几十万个key，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！

2. 惰性删除。定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，
还停留在内存里，这时你的系统去查一下那个 key，才会被redis给删除掉。

* **redis使用的过期键值删除策略是：定期删除 + 惰性删除。**
---

### 6、缓存穿透
::: tip 解释
一般的缓存系统都是按key去缓存查询，如果不存在对应的value，就去查数据库。
一些恶意的请求会故意大量查询不存在的key，就会对数据库造成很大的压力，这就叫做缓存穿透。
简单的说就是故意避开缓存去数据库查询数据。场景：当客户端发起查询时，缓存中没有就会去查库，库里也没有，就会返回给客户端错误信息。
这样是没问题的，看起来逻辑是完美的。但是这里存在一个漏洞，那就是无论什么样的Key过来查，都接受它的请求，这就可能会被黑客抓住，发起大量请求，
并且key都是系统中没有的，库里也查不到对应的值，这样的Key称之为非法key。那么当大量这样的请求过来时都不会命中Redis，然后都会打到DB上，
当DB瞬时接收到如此多的连接时，DB就有可能撑不住，挂掉。这就是存在的一个隐藏的漏洞，黑客或者恶意攻击者就会抓住这一点攻击你的系统，使你的系统瘫痪。
:::

* 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

* 另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），
我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。
---

### 7、缓存击穿
::: tip 解释
针对缓存中没有但数据库有的数据。场景是，当Key失效后，假如瞬间突然涌入大量的请求，来请求同一个Key，这些请求不会命中Redis，都会请求到DB，
导致数据库压力过大，甚至扛不住，挂掉。
:::

* 设置热点Key永不过期。

* 加互斥锁。当发现没有命中Redis，获取锁并从数据库取数据更新到缓存。这样就防止都去数据库重复取数据，重复往缓存中更新数据情况出现。
---

### 8、缓存雪崩
::: tip 解释
缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至宕机。和缓存击穿不同的是, 缓存击穿指并发查同一条数据，
缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。简单地说就是缓存大量过期去数据库查询数据。
:::
* 设置key过期时间时，加上一个随机数
---

### 9、如何保证缓存与数据库双写时的数据一致性
::: tip Cache Aside Pattern
* 读的时候先读缓存，有缓存直接返回；如果缓存不存在的话就读数据库，取出数据后更新缓存。
* 写的时候，先更新数据库，再<b>删除</b>缓存。
:::

* 如果不是严格要求“缓存和数据库”必须保证一致性的话，最好不要做这个方案：即 读请求和写请求串行化，串到一个内存队列里面去。
串行化可以保证一定不会出现不一致的情况，但会导致系统吞吐量大幅度降低。

#### 为什么是删除缓存，而不是更新缓存？
* 很多时候复杂的缓存场景，缓存可能是关联多张表的数据并通过计算得到缓存的值，即更新缓存的代价比较高。
对于需要频繁写操作，而读操作很少的时候，每次进行数据库的修改，缓存也要随之更新，会造成系统吞吐的下降。
* 两个并发写请求过来，可能会导致数据不一致，例如：A写库，B写库，B更新缓存，A更新缓存

#### Cache Aside Pattern存在的问题
* 问题：先更新数据库，再删除缓存，如果删除缓存失败了，导致数据库中是新数据，缓存中是旧数据，就出现数据不一致的问题。

* 并发问题：比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，
此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。
这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。
而实际上数据库的写操作会比读操作慢得多，而且还要加锁，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，
所有的这些条件都具备的概率基本并不大。

### 10、查找key
* 1. 使用keys指令可以扫出指定模式的key列表：keys pre*
> redis是单线程的。keys指令会导致线程阻塞一段时间，直到指令执行完毕，才能相应其他客户端请求
* 2. 使用scan
> scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。

### 11、底层数据结构
* [sds - 简单动态字符串](https://redisbook.readthedocs.io/en/latest/internal-datastruct/sds.html)
* [zset - 跳跃表skiplist](https://bex.meishakeji.com/2020/04/08/Redis%E4%B9%8B%E8%B7%B3%E8%B7%83%E8%A1%A8/)
* 字典
* 链表
* 整数集合 intset
* 压缩列表 ziplist

### 12、rehash的实现
* [https://www.cnblogs.com/goodAndyxublog/p/13635904.html](https://www.cnblogs.com/goodAndyxublog/p/13635904.html)

::: tip 相关链接

[https://juejin.cn/post/6844903604998914055](https://juejin.cn/post/6844903604998914055)

:::
