# FAQ
---

### 1、Redis为什么快
* 单线程
* 基于内存操作
* 利用io多路复用机制

### 2、Redis支持哪几种数据类型？
* 字符串String
* 字典Hash
* 列表List
* 集合Set
* 有序集合SortedSet
* **如果你是Redis中高级用户，还需要加上下面几种数据结构[Bitmap](https://www.cnblogs.com/wuhaidong/articles/10389484.html)、
    [HyperLogLog](https://segmentfault.com/a/1190000020523110)、Geo、Pub/Sub。**

### 3、Redis持久化机制（默认机制是RDB）
* RDB持久化分两种：save和bgsave。
  * save是阻塞式的，执行时redis的主进程把内存里的数据写入到RDB文件中，直到该文件创建完毕的这段时间内redis将不能处理任何命令请求；
  * bgsave属于非阻塞式，它会创建一个子进程专门去把内存中的数据写入RDB文件里，同时主进程还可以处理客户端的请求。

* AOF的持久化是通过命令追加、文件写入和文件同步三个步骤实现的。
  * 当redis开启AOF后，服务端每执行一次写操作（如set、sadd、rpush）就会把该条命令追加到一个单独的AOF缓冲区的末尾，然后把AOF缓冲区的内容写入AOF文件里。
  * 而何时进行文件同步则是根据配置的appendfsync来进行，appendfsync有三个选项：always、everysec（默认值）和no

* Redis AOF文件过大？
  * 随着命令不断的写入数据，AOF文件会越来越大。为了解决这个问题，redis引入了AOF文件重写机制，以便压缩AOF体积。
  * AOF重写的作用：减少磁盘占用量、加速恢复速度（AOF重写会整合一下，比如三条set改为一条）

* Redis 在 4.0 版本之后，引入了混合持久化方式，而且在 5.0 版本后默认开启。
  * RDB 加载速度快，但缺少最新数据。AOF 持续追加写记录，可以包含所有数据，但加载速度慢。混合模式一体化使用 RDB + AOF，包含全量数据，加载速度也比较快。
  > 可以使用 aof-use-rdb-preamble 配置来明确打开混合持久化模式。

  * 混合持久化也是通过 bgrewriteaof 来实现的。当启用混合存储后，进行 bgrewriteaof 时，主进程首先依然是 fork 一个子进程，
    子进程首先将内存数据以 RDB 的二进制格式写入 AOF 临时文件中。然后，再将落地期间缓冲的新增写指令，以命令的方式追加到该临时文件。
    然后再通知主进程落地完毕。主进程将临时文件修改为 AOF 文件，并关闭旧的 AOF 文件。这样主体数据以 RDB 格式存储，
    新增指令以命令方式追加的混合存储方式进行持久化（在同一个文件）。后续执行的任务，以正常的命令方式追加到新的 AOF 文件即可。

  * 混合持久化综合了 RDB 和 AOF 的优缺点，优势是包含全量数据，加载速度快。不足是头部的 RDB 格式兼容性和可读性较差。
---

### 4、redis重启时数据如何恢复
* 当appendonly配置项为no时redis启动后会去加载RDB文件来恢复数据

* 而appendonly配置项为yes时redis启动后会加载AOF文件来恢复数据
> 如果同时配置了aof-use-rdb-preamble yes，那么以混合方式恢复
---

### 5、如何保证缓存与数据库双写时的数据一致性
::: tip Cache Aside Pattern
* 读的时候先读缓存，有缓存直接返回；如果缓存不存在的话就读数据库，取出数据后更新缓存。
* 写的时候，先更新数据库，再<b>删除</b>缓存。
:::

* 如果不是严格要求“缓存和数据库”必须保证一致性的话，最好不要做这个方案：即 读请求和写请求串行化，串到一个内存队列里面去。
串行化可以保证一定不会出现不一致的情况，但会导致系统吞吐量大幅度降低。

#### 为什么是删除缓存，而不是更新缓存？
* 很多时候复杂的缓存场景，缓存可能是关联多张表的数据并通过计算得到缓存的值，即更新缓存的代价比较高。
对于需要频繁写操作，而读操作很少的时候，每次进行数据库的修改，缓存也要随之更新，会造成系统吞吐的下降。
* 两个并发写请求过来，可能会导致数据不一致，例如：A写库，B写库，B更新缓存，A更新缓存

#### Cache Aside Pattern存在的问题
* 问题：先更新数据库，再删除缓存，如果删除缓存失败了，导致数据库中是新数据，缓存中是旧数据，就出现数据不一致的问题。

* 并发问题：比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，
此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。
这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。
而实际上数据库的写操作会比读操作慢得多，而且还要加锁，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，
所有的这些条件都具备的概率基本并不大。

### 6、查找key
* 1. 使用keys指令可以扫出指定模式的key列表：keys pre*
> redis是单线程的。keys指令会导致线程阻塞一段时间，直到指令执行完毕，才能相应其他客户端请求
* 2. 使用scan
> scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。

### 7、底层数据结构
* [sds - 简单动态字符串](https://redisbook.readthedocs.io/en/latest/internal-datastruct/sds.html)
* [zset - 跳跃表skiplist](https://bex.meishakeji.com/2020/04/08/Redis%E4%B9%8B%E8%B7%B3%E8%B7%83%E8%A1%A8/)
* [哈希表](https://juejin.cn/post/6844903862961176584)
  * [rehash的实现](https://www.cnblogs.com/goodAndyxublog/p/13635904.html)
* 链表
* 整数集合 intset
* 压缩列表 ziplist

::: tip 参考链接

[https://juejin.cn/post/6844903604998914055](https://juejin.cn/post/6844903604998914055)

:::
