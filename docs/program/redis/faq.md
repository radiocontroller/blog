# FAQ
---

### 1、Redis为什么快
* 单线程
* 基于内存操作
* [利用io多路复用机制](https://journey-c.github.io/io-multiplexing/)

### 2、Redis支持哪几种数据类型？
* 字符串String
* 字典Hash
* 列表List
* 集合Set
* 有序集合SortedSet
* **如果你是Redis中高级用户，还需要加上下面几种数据结构[Bitmap](https://www.cnblogs.com/wuhaidong/articles/10389484.html)、
    [HyperLogLog](https://segmentfault.com/a/1190000020523110)、Geo、Pub/Sub。**

### 3、Redis持久化机制（默认机制是RDB）
* 第一种是RDB，全量备份。RDB持久化命令有两种：**save** 和 **bgsave**。
  * **save** 是阻塞的，执行时redis主进程把内存中的额数据写入到RDB文件中，直到该文件创建完毕的这段时间内redis将不能处理任何命令请求；
  * **bgsave** 是非阻塞的，它会创建一个子进程去把内存中的数据写入RDB文件中，同时主进程还可以处理客户端的请求（Copy On Write）。

* 第二种是AOF，是连续的增量备份，记录的是内存数据修改的指令。
  * **AOF重写**
    * Redis 在长期运行的过程中，AOF 的日志会越变越大。如果实例宕机重启，重放整个 AOF 日志会非常耗时，导致长时间 Redis 无法对外提供服务。所以需要对 AOF 日志重写。
    * Redis 提供了 bgrewriteaof 指令用于对 AOF 日志进行重写。其原理就是开辟一个子进程对内存进行遍历转换成一系列 Redis 的操作指令，
    序列化到一个新的 AOF 日志文件中。序列化完毕后再将操作期间发生的增量 AOF 日志追加到这个新的 AOF 日志文件中，追加 完毕后就立即替代旧的 AOF 日志文件。
  * **fsync**
    * AOF 日志是以文件的形式存在的，当程序对 AOF 日志文件进行写操作时，实际上是将内容写到了内存缓冲，然后内核会异步将脏数据刷回到磁盘。
    这就意味着如果机器突然宕机，AOF 日志内容可能还没有来得及完全刷到磁盘中，这个时候就会出现日志丢失。
    * Redis提供了有三个appendfsync选项：always、everysec（默认值）和no

* Redis 在 4.0 版本之后，引入了混合持久化方式，而且在 5.0 版本后默认开启。
  * RDB 加载速度快，但缺少最新数据。AOF 持续追加写记录，可以包含所有数据，但加载速度慢。混合模式一体化使用 RDB + AOF，包含全量数据，加载速度也比较快。
  > 可以使用 aof-use-rdb-preamble 配置来明确打开混合持久化模式。

  * 混合持久化也是通过 bgrewriteaof 来实现的。当启用混合存储后，进行 bgrewriteaof 时，主进程首先依然是 fork 一个子进程，
    子进程首先将内存数据以 RDB 的二进制格式写入 AOF 临时文件中。然后，再将持久化期间新增的写指令，以命令的方式追加到该临时文件。
    然后再通知主进程执行完毕。主进程将临时文件修改为 AOF 文件，并关闭旧的 AOF 文件。这样主体数据以 RDB 格式存储，
    新增指令以命令方式追加的混合存储方式进行持久化。后续执行的任务，以正常的命令方式追加到新的 AOF 文件即可。

  * 混合持久化综合了 RDB 和 AOF 的优缺点，优势是包含全量数据，加载速度快。不足是头部的 RDB 格式兼容性和可读性较差。
---

### 4、redis重启时数据如何恢复
* 当appendonly配置项为no时redis启动后会去加载RDB文件来恢复数据

* 而appendonly配置项为yes时redis启动后会加载AOF文件来恢复数据
> 如果同时配置了aof-use-rdb-preamble yes，那么以混合方式恢复
---

### 5、如何保证缓存与数据库双写时的数据一致性
::: tip Cache Aside Pattern
* 读的时候先读缓存，有缓存直接返回；如果缓存不存在的话就读数据库，取出数据后更新缓存。
* 写的时候，先更新数据库，再<b>删除</b>缓存。
:::

* 如果不是严格要求“缓存和数据库”必须保证一致性的话，最好不要做这个方案：即 读请求和写请求串行化，串到一个内存队列里面去。
串行化可以保证一定不会出现不一致的情况，但会导致系统吞吐量大幅度降低。

#### 为什么是删除缓存，而不是更新缓存？
* 很多时候复杂的缓存场景，缓存可能是关联多张表的数据并通过计算得到缓存的值，即更新缓存的代价比较高。
对于需要频繁写操作，而读操作很少的时候，每次进行数据库的修改，缓存也要随之更新，会造成系统吞吐的下降。
* 两个并发写请求过来，可能会导致数据不一致，例如：A写库，B写库，B更新缓存，A更新缓存

#### Cache Aside Pattern存在的问题
* 问题：先更新数据库，再删除缓存，如果删除缓存失败了，导致数据库中是新数据，缓存中是旧数据，就出现数据不一致的问题。

* 并发问题：比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，
此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。
这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。
而实际上数据库的写操作会比读操作慢得多，而且还要加锁，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，
所有的这些条件都具备的概率基本并不大。

### 6、查找key
* 1. 使用keys指令可以扫出指定模式的key列表：keys pre*
> redis是单线程的。keys指令会导致线程阻塞一段时间，直到指令执行完毕，才能相应其他客户端请求
* 2. 使用scan
> scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。

### 7、底层数据结构
* [sds - 简单动态字符串](https://redisbook.readthedocs.io/en/latest/internal-datastruct/sds.html)
* [zset - 跳跃表skiplist](https://bex.meishakeji.com/2020/04/08/Redis%E4%B9%8B%E8%B7%B3%E8%B7%83%E8%A1%A8/)
* [哈希表](https://juejin.cn/post/6844903862961176584)
  * [rehash的实现](https://www.cnblogs.com/goodAndyxublog/p/13635904.html)
* 链表
* 整数集合 intset
* 压缩列表 ziplist

::: tip 参考链接

[https://juejin.cn/post/6844903604998914055](https://juejin.cn/post/6844903604998914055)

:::
