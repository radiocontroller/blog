# 缓冲池(buffer pool)以及LRU
---

### 为了减少磁盘IO，加快数据访问，Mysql引入了buffer pool，先看下它的结构
![buffer_pool](https://moto-1252807079.cos.ap-shanghai.myqcloud.com/program/mysql/buffer_pool.png)

### 预读以及它和缓冲池的关系
* Mysql中的数据页大小是16KB，缓冲池中的缓存页也是16KB，它们一一对应
* 从磁盘上加载一个数据页的时候，可能会连带着把这个数据页相邻的其他数据页，也加载到缓存里去。如果未来要读取的数据就在这些页中，
就能够省去后续的磁盘IO，提高效率（**局部性原理**）

### 缓冲池的管理
* **Mysql采用的是传统LRU的变种，它解决了两个问题**
  1. **预读失效**：由于预读(Read-Ahead)，提前把页放入了缓冲池，但最终MySQL并没有从页中读取数据，称为预读失效。
      * 解决办法：划分新生代和老生代，预读出来的页数据先放在【老生代头部】，如果后续有访问到该页（例如查找页中某一行），再将
        该页移动到【新生代头部】
  2. **缓冲池污染**：当某一个SQL语句，要批量扫描大量数据时，可能把缓冲池的所有页都替换出去，导致大量热数据被换出
      * 解决办法：加入一个【老生代停留时间窗口】的机制，只有满足【被访问】并且【在老生代停留时间】大于T，才会被放入新生代头部

* **什么时候缓冲池中的页，会刷到磁盘上呢？**
  * MySQL 会有一条后台线程，定时地将 Buffer Pool 中的脏页刷回到磁盘文件中
      
### 写缓冲（change buffer）
* 它是一种应用在【**非唯一普通索引页**】不在缓冲池中，对页进行了写操作（insert/update/delete），并不会立刻将磁盘页加载到缓冲池，
而仅仅记录缓冲变更，等未来数据被读取时，再将数据合并(merge)恢复到缓冲池中的技术。写缓冲的目的是降低写操作的磁盘IO，提升数据库性能。

* **假如要修改页号为40的索引页，而这个页不在缓冲池内(ps: 如果在缓冲池页中就直接改)**
![buffer_pool1](https://moto-1252807079.cos.ap-shanghai.myqcloud.com/program/mysql/buffer_pool1.png)

* **加入写缓冲优化后，流程优化为：**
  1. 在写缓冲中记录这个操作，一次内存操作
  2. 写入**redo log**，一次磁盘顺序写操作
  
* **是否会出现一致性问题呢？（答：不会）**
  1. 数据库异常奔溃，能够从redo log中恢复数据
  2. 写缓冲不只是一个内存结构，它也会被定期刷盘到系统表空间
  3. 从磁盘读取数据页到缓冲池时，会有另外的流程，将写缓冲合并到缓冲池
   
* **假设稍后有请求查询索引页40的数据**
![buffer_pool2](https://moto-1252807079.cos.ap-shanghai.myqcloud.com/program/mysql/buffer_pool2.png)

* **此时的流程：**
  1. 缓冲池未命中，从磁盘中读取数据页
  2. 从写缓冲读取相关信息
  3. 恢复索引页（数据页 + 写缓冲数据），放到缓冲池LRU里
  
* **可以看到，40这一页，在真正被读取时，才会被加载到缓冲池中**

* **最后我们来说一说为什么是应用在【<b>非唯一普通索引页</b>】。如果索引设置了唯一(unique)属性，在进行修改操作时，InnoDB必须进行唯一性检查。
    按照上面的逻辑，只有真正在读取的时候才加载到缓冲池，那么怎么去校验唯一呢？校验唯一就必须进行一次磁盘IO，这与写缓冲为了减少磁盘IO的思想违背了。**

::: tip 相关链接

[缓冲池(buffer pool)，这次彻底懂了！！！](https://juejin.cn/post/6844903874172551181)

[写缓冲(change buffer)，这次彻底懂了！！！](https://juejin.cn/post/6844903875271475213)

[缓冲池](https://github.com/asdbex1078/MySQL/blob/master/mysql-storage-engines/innodb/1.2.0.InnoDB%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BC%93%E5%86%B2%E6%B1%A0.md)
:::